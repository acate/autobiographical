{
    "collab_server" : "",
    "contents" : "library(lme4) # for lmer\nlibrary(lsr) # for etaSquared\nlibrary(multcomp) # for glht\nlibrary(ggplot2) # for nice plots\nlibrary(sjstats) # for ANOVA effect size functions\nlibrary(ggpubr) # for qq plot and ggdensity\nlibrary(car) # for Anova\nlibrary(ez) # for ezANOVA\n\n# load functions\ncodeDir <- \"./\"\nsource(paste0(codeDir,'loosenup_HolesFMRI_behav_functions.R'))\n\n# Define plot dir.\nplotDir <- \"~/Google Drive/VNLab/studies/HolesFMRI/summaries/figs/\"\n\n\n\ndf <- read.csv(\"~/Google Drive/VNLab/studies/HolesFMRI/data/Holes_data_backup/HolesFMRI_behav_data.txt\", na.strings=\"NaN\")\n\ndf$run <- factor(df$run);\ndf$fixLum <- factor(df$fixLum);\ndf$condition <- factor(df$condition);\ndf$fixDepth <- factor(df$fixDepth);\ndf$rectExemplar <- factor(df$rectExemplar);\n\n# Make new variable that assigns a level to baseline (\"FD0\" fixation depth zero -- no disparity) trials for \"depthCond\" factor.  Current depthCond var. just has NAs for these trials\n\n# Copy factor\ndf$dcAll <- df$depthCond\n\n# Need to define new possible level before assigning new level value\nlevels(df$dcAll) <- c(levels(df$dcAll),\"zero\")\n\ndf$dcAll[is.na(df$depthCond)] <- \"zero\"\n\n\n# Make new variable that cateagorizes fixDepth by absolute disparity (i.e. lumps together levels 1,4 and 2,3)\n# Will still have level \"0\" for baseline trials\n\ndf$fdAbs <- df$fixDepth\n\ndf$fdAbs[df$fixDepth %in% c(\"2\",\"3\")] <- \"1\"\ndf$fdAbs[df$fixDepth %in% c(\"1\",\"4\")] <- \"2\"\n\ndf$fdAbs <- droplevels(df$fdAbs)\n\n\n# Make new variable the categorizes fixDepth by sign of disparity (i.e. crossed/uncrossed) (i.e. lumps together 1,2 and 3,4)\n\ndf$fdSign <- df$fixDepth\n\ndf$fdSign[df$fixDepth %in% c(\"1\",\"2\")] <- \"1\"\ndf$fdSign[df$fixDepth %in% c(\"3\",\"4\")] <- \"2\"\n\ndf$fdSign <- droplevels(df$fdSign)\n\n\n# Rename levels of disparity factors\n\n\nlevels(df$fixDepth) <- c(\"0\",\"18' crossed\",\"6' crossed\",\"6' uncrossed\",\"18' uncrossed\")\n\nlevels(df$fdAbs) <- c(\"0\",\"6'\",\"18'\")\n\nlevels(df$fdSign) <- c(\"0\",\"crossed\",\"uncrossed\")\n\n# These subjects were not included in the neuroimaging analysis:\n# H9, H12, H18, H22\n\n\n# Make df that leaves out subjects\n# H25-28 have no RTs, only NAs\ndfSub <- subset(df, !(sub %in% c(\"H9\",\"H12\",\"H18\",\"H22\",\"H25\",\"H26\",\"H27\",\"H28\")) );\ndfSub <- droplevels(dfSub)\n\n\n\n\n# Version of df that leaves out baseline blocks where fixation depth was same as screen\ndfSubFD0 <- subset(dfSub, fixDepth != \"0\");\ndfSubFD0 <- droplevels(dfSubFD0);\n\n\n# Version of df that includes only conditions where all depth conditions occurred, for balanced design\n\ndfSubBal <- subset(dfSub, fdAbs != \"18'\")\ndfSubBal <- droplevels(dfSubBal)\n\n\n\n\n\n\n\n# # nice summary of who might have fallen asleep and during which runs\n# # enlarge to be able to see all x-axis labels (subject IDs)\n# barplot(tapply(NORESP,list(run,sub),sum))\n\n# Same info in table form\ntapply(NORESP,list(run,sub),sum)\nsortedRates <- sort(tapply(NORESP,sub,mean)*100)\n\n# Highest NORESP rates:\n# H12 (7.5%), H22 (4.92%), H26 (3.54%); first two not included in fMRI analysis\n\nmean(sortedRates) # 1.073\nsd(sortedRates) # 1.94\n\nmeanPlus2SD <- mean(sortedRates) + 2*sd(sortedRates) # 4.95\n\n# Only H12 is more than 2 SDs above mean, although H22 is very close\n\n\n#stop();\n# Halt execution here\n\n# Error rates\nsortedRatesINCORR <- sort(tapply(INCORR,sub,mean)*100)\nmean(sortedRatesINCORR) # 0.88%\nsd(sortedRatesINCORR) # 0.64%\nmax(sortedRatesINCORR) # 2.56% (H8)\n\n# # ANOVAs of errors\n# aovInCorrRM <- aov(INCORR ~ depthCond*fixLum + Error(sub),data=na.omit(dfSub));\n# aovInCorr <- aov(INCORR ~ depthCond*fixLum ,data=dfSub);\n\n\n# RT by sub\nsortedRatesRT <- sort(with(na.omit(dfSub),tapply(RTCORRECT,sub,mean)))\nmean(sortedRatesRT) # 0.688\nsd(sortedRatesRT) # 0.127\nmax(sortedRatesRT) # 0.988 (H24 - this is more than plus 2 sd's)\n\n\n# Tests for normality\n\n# # Histogram of log correct RTs\n#\n# pRT <- ggplot(dfSub,aes(RTCORRECT)) + geom_histogram()\n# pLogRT <- ggplot(dfSub,aes(log(RTCORRECT))) + geom_histogram()\n#\n# # Other functions, including qqplots\n#\n# # See http://www.sthda.com/english/wiki/normality-test-in-r\n#\n# ggdensity(dfSub$RTCORRECT)\n# ggqqplot(dfSub$RTCORRECT)\n\n# # Normality tests\n# ks.test(x=((dfSub$RTCORRECT)),y=\"pnorm\")\n\n# The following doesn't work because sample size is too large:\n# shapiro.test((dfSub$RTCORRECT))\n\n####### NOTE ########\n# Decided that not going to worry about normality violations for RT\n#####################\n\n\n\n\n\n\n# ANOVA\n# If really care about repeated measures methods, should always visit:\n# https://gribblelab.wordpress.com/2009/03/09/repeated-measures-anova-using-r/\n\n\n\n# aovLogRTSub <- aov(RTCORRECT ~ depthCond*fixLum*fixDepth + Error(sub),data=na.omit(dfSub));\n#\n# aovLogRTSub <- aov(RTCORRECT ~ depthCond*fdAbs*fixLum + Error(sub/(depthCond*fdAbs*fixLum)),data=na.omit(dfSub));\n#\n#\n#\n# aovLogRTFixed <- aov(RTCORRECT ~ depthCond*fixLum*fixDepth,data=na.omit(dfSub));\n#\n# aovLogRTfdAbsSignSub <- aov(RTCORRECT ~ depthCond*fixLum*fdAbs*fdSign + Error(sub),data=na.omit(dfSubFD0));\n#\n#\n# # Both show main effects of depthCond and fixLum\n# summary(aovLogRTSub)\n# summary(aovLogRTFixed)\n\n\nrt_anova_fdAbs = ezANOVA(\n  data = na.omit(dfSub)\n  , dv = .(RTCORRECT)\n  , wid = .(sub)\n  , within = .(fixLum,depthCond,fdAbs,run)\n  , within_full = .(fixLum,depthCond,fdAbs,fdSign,run,rectExemplar)\n)\n\nprint(rt_anova_fdAbs)\n\n\nrt_anova_fdSign = ezANOVA(\n  data = na.omit(dfSub)\n  , dv = .(RTCORRECT)\n  , wid = .(sub)\n  , within = .(fixLum,depthCond,fdSign,run)\n  , within_full = .(fixLum,depthCond,fdAbs,fdSign,run,rectExemplar)\n)\n\nprint(rt_anova_fdSign)\n\n\n\nrt_anova_dcAll = ezANOVA(\n  data = na.omit(dfSub)\n  , dv = .(RTCORRECT)\n  , wid = .(sub)\n  , within = .(fixLum,dcAll,run)\n  , within_full = .(fixLum,dcAll,fdAbs,fdSign,run,rectExemplar)\n)\n\nprint(rt_anova_dcAll)\n\n\nrt_anova_Bal = ezANOVA(\n  data = na.omit(dfSubBal)\n  , dv = .(RTCORRECT)\n  , wid = .(sub)\n  , within = .(fixLum,depthCond,fdSign,run)\n  , within_full = .(fixLum,depthCond,fdSign,run,rectExemplar)\n)\n\nprint(rt_anova_Bal)\n\n\n\n\n# # pairwise t-tests, can't do paired=T for dfCorrect, because \"not all arguments have same length\"; works if set paired=F (which is actually the default)\n# with(dfSub,pairwise.t.test(log(RTCORRECT), interaction(depthCond,fixLum), p.adjust.method=\"bonf\", paired=F))\n\n# Shows flat != vex, no other pairs sig.\nwith(dfSub,pairwise.t.test(log(RTCORRECT), depthCond, p.adjust.method=\"bonf\", paired=F))\n\nwith(dfSub,pairwise.t.test(log(RTCORRECT), dcAll, p.adjust.method=\"bonf\", paired=F))\n\nwith(dfSub,pairwise.t.test(log(RTCORRECT), fdAbs, p.adjust.method=\"bonf\", paired=F))\n\n\nwith(dfSubFD0,pairwise.t.test(log(RTCORRECT), interaction(run,fdAbs), p.adjust.method=\"bonf\", paired=F))\n\n# For Balanced design (small Abs disparities only)\n\nwith(dfSubBal,pairwise.t.test(log(RTCORRECT), depthCond, p.adjust.method=\"bonf\", paired=F))\n\nwith(dfSubBal,pairwise.t.test(log(RTCORRECT), dcAll, p.adjust.method=\"bonf\", paired=F))\n\n\n\n\n\n# # Better\n# aovLogRTFullSub <- with(na.omit(dfSub),aov(log(RTCORRECT) ~ depthCond*fixLum*run*rectExemplar*fixDepth + Error(sub)));\n#\n#\n# aovLogRTfdAbsSignFullSub <- aov(log(RTCORRECT) ~ depthCond*fixLum*run*rectExemplar*fdAbs*fdSign + Error(sub/(depthCond + fixLum + run + rectExemplar + fdAbs +fdSign)),data=na.omit(dfSub));\n#\n# aovLogRTfdAbsSignFullFixed <- aov(log(RTCORRECT) ~ depthCond*fixLum*run*rectExemplar*fdAbs*fdSign,data=dfSub);\n\n\n\n## CONCLUSION\n# Absolute disparity affects RT but not disparity sign\n# Concave and convex RTs NOT different!\n\n\n\n\n\n# # Show sig main effects for depthCond, fixLum, and run\n# aovLogRTFullFixed <- with(dfSub,aov(log(RTCORRECT) ~ depthCond*fixLum*run*rectExemplar*fixDepth));\n#\n# # Weirdly (?) results not different from above\n# aovLogRTFulldcAllFixed <- with(dfSub,aov(log(RTCORRECT) ~ dcAll*fixLum*run*rectExemplar*fixDepth));\n#\n#\n# summary(aovLogRTFullSub)\n# summary(aovLogRTFullFixed)\n#\n# thsdLogRTFullFixed <- TukeyHSD(aovLogRTFullFixed)\n#\n# thsdLogRTfdAbsSignFullFixed <- TukeyHSD(aovLogRTfdAbsSignFullFixed)\n#\n#\n# # For some reason level \"zero\" doesn't appear here\n# #thsdLogRTFulldcAllFixed <- TukeyHSD(aovLogRTFulldcAllFixed)\n#\n#\n# thsdLogRTFullFixed$depthCond\n#\n# thsdLogRTfdAbsSignFullFixed$depthCond\n# thsdLogRTfdAbsSignFullFixed$fdAbs\n# thsdLogRTfdAbsSignFullFixed$run\n# thsdLogRTfdAbsSignFullFixed$fixLum\n# thsdLogRTfdAbsSignFullFixed$`run:fdAbs`\n\n\n# thsdLogRTFulldcAllFixed$dcAll\n\n\n\n\n## MEANS of conditions\n\n\ndfWSdepthCond <- summarySEwithin(\n  data = na.omit(dfSub),\n  measurevar = \"RTCORRECT\",\n  withinvars = \"depthCond\",\n  idvar = \"sub\"\n)\n\n\ndfWSfixDepth <- summarySEwithin(\n  data = na.omit(dfSub),\n  measurevar = \"RTCORRECT\",\n  withinvars = \"fixDepth\",\n  idvar = \"sub\",\n  na.rm = TRUE\n)\n\n# Can't get level \"0\" to show up from this last one, so do kludge instead:\n\n# Make table of fixDepth by sub, with na.rm=T\n# Will be a mtrix until coerced to data frame\nfdBySub <- as.data.frame(with(dfSub,tapply((RTCORRECT),list(sub,fixDepth),mean,na.rm=T)))\n\n# Now can take means and sd's\n\nfd0Mean <- mean(fdBySub$`0`)\nfd0SD <- sd(fdBySub$`0`)\n\n\n# Table of these data; na.rm=TRUE is needed here\nwith(dfSub,tapply((RTCORRECT),fixDepth,mean,na.rm=TRUE))\n\n\ndfWSfdAbs <- summarySEwithin(\n  data = na.omit(dfSub),\n  measurevar = \"RTCORRECT\",\n  withinvars = \"fdAbs\",\n  idvar = \"sub\",\n  na.rm = TRUE\n)\n\ndfWSfdAbsByRun <- summarySEwithin(\n  data = na.omit(dfSub),\n  measurevar = \"RTCORRECT\",\n  withinvars = c(\"fdAbs\",\"run\"),\n  idvar = \"sub\",\n  na.rm = TRUE\n)\n\n\n# Balanced design version\n\ndfWSdepthCondBal <- summarySEwithin(\n  data = na.omit(dfSubBal),\n  measurevar = \"RTCORRECT\",\n  withinvars = \"depthCond\",\n  idvar = \"sub\"\n)\n\n\n\n\n# # Run 3 different from all others\n# with(dfCorrect,pairwise.t.test(log(RT), run, p.adjust.method=\"bonf\", paired=F))\n#\n# # No sig. diffs\n# with(df,pairwise.t.test(INCORR, run, p.adjust.method=\"bonf\", paired=F))\n#\n# # Only LACK of diff is 2-4\n# with(df,pairwise.t.test(NORESP, run, p.adjust.method=\"bonf\", paired=F))\n\ntapply(NORESP,list(run),mean)\ntapply(INCORR,list(run),mean)\n\n# # Main effect of run\n# aovIncorrFull <- aov(INCORR ~ depthCond*fixLum*run*rectExemplar);\n# summary(aovIncorrFull)\n#\n# # Main effect of run for Within stratum\n# aovIncorrFullRM <- aov(INCORR ~ depthCond*fixLum*run*rectExemplar + Error(sub));\n# summary(aovIncorrFullRM)\n#\n# tapply(INCORR,list(depthCond,rectExemplar),mean)\n\n\n\n\n# Main effect of fixDepth; interactions of fixDepth with depthCond and run\n# aovLogRTFullFD0Fixed <- aov(log(RTCORRECT) ~ depthCond*fixLum*run*fixDepth*rectExemplar,data=dfSubFD0)\n\n# # Table of these data; na.rm=TRUE is needed here\n# with(dfSub,tapply(log(RTCORRECT),depthCond,mean,na.rm=TRUE))\n\n\n# INTERESTING: results suggest that subs get used to different pattern of converging by Run 4?  Inferred from fact that RT slower for larger abs. disparities at first, then opposite in Run 4.\n# with(na.omit(dfSubFD0),interaction.plot(run,fixDepth,log(RT)))\n\npRunFdAbs <- acPlotRTWSrunFdAbs(na.omit(dfSub))\n\nsvg(\n  paste0(plotDir,'RT_runByFdAbs.svg')\n)\nprint(pRunFdAbs)\ndev.off()\n\n# CONCLUSION:\n# Absolute disparity differences only significant during first block/run\n\n\n\n\n##########\n###### MAKE ggplot2 with within-subject (\"WS\") error bars of this last effect\n##########\n\npFixDepth <- acPlotRTWS(na.omit(dfSub))\npfdAbs <- acPlotRTWSfdAbs(na.omit(dfSub))\npfdSign <- acPlotRTWSfdSign(na.omit(dfSub))\n\nsvg(\n  paste0(plotDir,'RT_fixDepth.svg')\n)\nprint(pFixDepth)\ndev.off()\n\nsvg(\n  paste0(plotDir,'RT_fdAbs.svg')\n)\nprint(pfdAbs)\ndev.off()\n\n\n\nstop()\n\n\n\n\n\n\n\n\n\n\n\n\n\n# to see how fixLum effect pans out across indiv. subs:\nx <- with(na.omit(dfSub),tapply(RTCORRECT,list(fixLum,sub),mean))\nlumDiff <- x[1,] - x[2,]\nbarplot(lumDiff)\n\n\n\n# library(lsr)\n\netaSquared(aovLogRT)\n\ndfSubCond0 <- subset(df, depthCond != \"0\");\ndfSubCond0 <- droplevels(dfSubCond0);\n\naovLogRTCond <- with(dfSubCond0,aov(log(RT) ~ condition))\nsummary(aovLogRTCond)\n\naovIncorrCond <- with(dfSubCond0,aov(INCORR ~ condition))\nsummary(aovIncorrCond)\n\netaSquared(aovIncorrCond)\netaSquared(aovLogRTCond)\n\nwith(na.omit(dfSubCond0),pairwise.t.test(log(RT),condition,p.adjust.method = \"bonf\",pool.sd = T))\nwith((dfSubCond0),pairwise.t.test(INCORR,condition,p.adjust.method = \"bonf\",pool.sd = T))\n\naovLogRTCondRun <- with(dfSubCond0,aov(log(RT) ~ condition*run))\nsummary(aovLogRTCondRun)\n\nwith(na.omit(dfSubCond0),tapply(RT,list(condition,run),mean))\nbarplot(with(na.omit(dfSubCond0),tapply(log(RT),list(run,condition),mean)))\n\n\n\n# Linear regression\n\nlmFullAbsSign <- lm(log(RTCORRECT) ~ depthCond*fixLum*run*rectExemplar*fdAbs*fdSign, data=dfSubFD0)\n\nAnova(lmFullAbsSign)\n\n\nlmerFullAbsSign <- lmer(log(RTCORRECT) ~ (1|sub) + depthCond*fixLum*run*rectExemplar*fdAbs, data=dfSub)\n\nAnova(lmerFullAbsSign)\n\n# lm <- lm(log(RTCORRECT) ~ depthCond*fixLum*fdAbs*fdSign, data=dfSubFD0)\n\n\n# library(multcomp)\n\nlmCond <- lm(log(RT) ~ condition, data=df)\nsummary(lmCond)\n\n# test concave vs. convex\nK <- matrix(c(0,0,0,0,0,-1/4,1/4,-1/4,1/4,-1/4,1/4), 1)\nt <- glht(lmCond, linfct = K)\nsummary(t)\n\n# \"subtract the appropriate flat baseline\" from both cave and vex:\n#apparently don't need to divide by sum of coefs.\nK <- matrix(c(0,1,0,0,-1,-1,1,-1,1,-1,1), 1)\nt <- glht(lmCond, linfct = K)\n\n\nlmerCond <- lmer(log(RT) ~ (1|sub) + condition, data=df)\nsummary(lmerCond)\n\n# shows effect\nK <- matrix(c(0,0,0,0,0,-1,1,-1,1,-1,1), 1)\nt <- glht(lmerCond, linfct = K)\nsummary(t)\n\n# should be more appropriate\n\n# shows null effect\nK <- matrix(c(0,1,0,0,-1,-1,1,-1,1,-1,1), 1)\nt <- glht(lmerCond, linfct = K)\n\nsummary(t)\n\n\nlmerCondFL <- lmer(log(RT) ~ (1|sub) + condition*fixLum, data=df)\nsummary(lmerCondFL)\nranef(lmerCondFL)\nfixef(lmerCondFL)\n\nlmerCondFLPlusRun <- lmer(log(RT) ~ (1|sub) + condition*fixLum + run, data=df)\nbarplot(fixef(lmerCondFLPlusRun))\n\nlmCondFL <- lm(log(RT) ~ condition*fixLum, data=df)\nanova(lmCond,lmCondFL)\n\nanova(lmerCond,lmerCondFL)\nanova(lmerCondFLPlusRun,lmerCondFL)\n\n# set up linear contrast using full model fixed effects coefs:\nlmerFE <- fixef(lmerCondFLPlusRun)\n\n# need to make this a matrix, and in row format!\nK <- t(as.matrix(numeric(length(lmerFE)))); # row vector (= list in R (?)) of zeros\n\n\n# need to make this a matrix, and in row format!\nK <- t(as.matrix(numeric(length(fixef(lmerCondFLPlusRun))))); # row vector (= list in R (?)) of zeros\n\n#K[1] is intercept coef.\nK[c(2,7,9,11)] <- 1; #concave and flat DC 1\nK[c(5,6,8,10)] <- -1; #vex and flat DC 4\n\nt <- glht(lmerCondFLPlusRun, linfct = K)\n\nsummary(t)\n\n\n# need to make this a matrix, and in row format!\nK <- t(as.matrix(numeric(length(lmerFE)))); # row vector (= list in R (?)) of zeros\n\n       #K[1] is intercept coef.\n       K[c(7,9,11)] <- 1; #concave conds ONLY\n       K[c(6,8,10)] <- -1; #vex conds ONLY\n\n       t <- glht(lmerCondFLPlusRun, linfct = K)\n\n       summary(t)\n\n# Test signif. of fixLum\n#--------------------------\n# need to make this a matrix, and in row format!\nK <- t(as.matrix(numeric(length(fixef(lmerCondFLPlusRun))))); # row vector (= list in R (?)) of zeros\n#K[1] is intercept coef.\nK[12] <- 1; #fixLum2 (=bright/ligth)\nt <- glht(lmerCondFLPlusRun, linfct = K)\nsummary(t)\n\n\n# mean RT by sub\nwith(na.omit(df),tapply(RT,list(sub),mean))\n",
    "created" : 1569540595239.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3092378703",
    "id" : "208F7A61",
    "lastKnownWriteTime" : 1559879846,
    "last_content_update" : 1559879846,
    "path" : "~/Google Drive/VNLab/studies/HolesFMRI/data/Holes_data_backup/loosenup_HolesFMRI_behav.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}